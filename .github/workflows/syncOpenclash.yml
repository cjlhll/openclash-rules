---
name: Mirror OpenClash Release to Repository

on:
  # 手动触发
  workflow_dispatch:
    inputs:
      force_update:
        description: '强制更新已存在的release'
        required: false
        default: 'false'
        type: boolean
  # 定时触发 - 每天检查一次
  schedule:
    - cron: '0 2 * * *'  # 每天凌晨2点执行

jobs:
  mirror-release:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      
    timeout-minutes: 30
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        
      - name: Install dependencies
        run: |
          # 确保必要工具已安装
          sudo apt-get update
          sudo apt-get install -y jq curl wget parallel
        
      - name: Get latest OpenClash release
        id: get_release
        run: |
          echo "🔍 正在获取OpenClash最新发布信息..."
          
          # 使用GitHub API获取最新的release信息（包括pre-release版本）
          LATEST_RELEASE=$(curl -s -H "Accept: application/vnd.github.v3+json" \
            "https://api.github.com/repos/vernesong/OpenClash/releases?per_page=1" | jq '.[0]')
          
          # 检查API响应是否有效
          if [ "$LATEST_RELEASE" = "null" ] || [ -z "$LATEST_RELEASE" ]; then
            echo "❌ 错误: 无法获取发布信息"
            exit 1
          fi
          
          # 检查是否为pre-release
          IS_PRERELEASE=$(echo "$LATEST_RELEASE" | jq -r '.prerelease')
          echo "📦 发现发布版本 - 预发布版本: $IS_PRERELEASE"
          
          # 提取release信息
          TAG_NAME=$(echo "$LATEST_RELEASE" | jq -r '.tag_name')
          RELEASE_NAME=$(echo "$LATEST_RELEASE" | jq -r '.name')
          PUBLISHED_AT=$(echo "$LATEST_RELEASE" | jq -r '.published_at')
          ASSETS_COUNT=$(echo "$LATEST_RELEASE" | jq '.assets | length')
          
          # 处理release body，转义特殊字符和换行符
          RELEASE_BODY_RAW=$(echo "$LATEST_RELEASE" | jq -r '.body')
          # 使用base64编码来安全传递包含特殊字符的内容
          RELEASE_BODY_ENCODED=$(echo "$RELEASE_BODY_RAW" | base64 -w 0)
          
          echo "tag_name=$TAG_NAME" >> $GITHUB_OUTPUT
          echo "release_name=$RELEASE_NAME" >> $GITHUB_OUTPUT
          echo "published_at=$PUBLISHED_AT" >> $GITHUB_OUTPUT
          echo "release_body_encoded=$RELEASE_BODY_ENCODED" >> $GITHUB_OUTPUT
          echo "assets_count=$ASSETS_COUNT" >> $GITHUB_OUTPUT
          
          echo "✅ 最新发布: $RELEASE_NAME ($TAG_NAME)"
          echo "📅 发布时间: $PUBLISHED_AT"
          echo "📁 资源文件数量: $ASSETS_COUNT"
          echo "📝 描述长度: ${#RELEASE_BODY_RAW} 字符"
          
      - name: Check if release already exists
        id: check_release
        run: |
          echo "🔍 检查发布版本是否已存在..."
          
          # 获取当前仓库的所有releases
          EXISTING_RELEASE=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            -H "Accept: application/vnd.github.v3+json" \
            "https://api.github.com/repos/${{ github.repository }}/releases/tags/${{ steps.get_release.outputs.tag_name }}")
          
          # 检查是否存在
          if echo "$EXISTING_RELEASE" | jq -e '.id' > /dev/null 2>&1; then
            echo "exists=true" >> $GITHUB_OUTPUT
            echo "release_id=$(echo "$EXISTING_RELEASE" | jq -r '.id')" >> $GITHUB_OUTPUT
            echo "📋 发布版本 ${{ steps.get_release.outputs.tag_name }} 已存在"
            echo "🆔 发布ID: $(echo "$EXISTING_RELEASE" | jq -r '.id')"
            
            # 检查是否强制更新
            FORCE_UPDATE="${{ github.event.inputs.force_update }}"
            if [ "$FORCE_UPDATE" = "true" ]; then
              echo "force_update=true" >> $GITHUB_OUTPUT
              echo "⚠️  强制更新模式已启用，将删除现有发布"
            else
              echo "force_update=false" >> $GITHUB_OUTPUT
              echo "ℹ️  跳过更新 - 如需强制更新，请在手动触发时启用 force_update 选项"
            fi
          else
            echo "exists=false" >> $GITHUB_OUTPUT
            echo "force_update=false" >> $GITHUB_OUTPUT
            echo "✅ 发布版本 ${{ steps.get_release.outputs.tag_name }} 不存在，将创建新发布"
          fi
          
      - name: Delete existing release if force update
        if: steps.check_release.outputs.exists == 'true' && steps.check_release.outputs.force_update == 'true'
        run: |
          echo "🗑️  正在删除现有发布..."
          
          # 删除现有的release
          curl -X DELETE \
            -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            -H "Accept: application/vnd.github.v3+json" \
            "https://api.github.com/repos/${{ github.repository }}/releases/${{ steps.check_release.outputs.release_id }}"
          
          if [ $? -eq 0 ]; then
            echo "✅ 现有发布已删除"
          else
            echo "❌ 删除现有发布失败"
            exit 1
          fi
          
          # 删除对应的tag
          echo "🏷️  正在删除现有标签..."
          curl -X DELETE \
            -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            -H "Accept: application/vnd.github.v3+json" \
            "https://api.github.com/repos/${{ github.repository }}/git/refs/tags/${{ steps.get_release.outputs.tag_name }}"
          
          echo "✅ 现有标签已删除，准备创建新发布"
          
      - name: Create new release with assets
        if: steps.check_release.outputs.exists == 'false' || steps.check_release.outputs.force_update == 'true'
        run: |
          echo "🚀 正在创建新的发布版本..."
          
          # 解码release body
          RELEASE_BODY=$(echo "${{ steps.get_release.outputs.release_body_encoded }}" | base64 -d)
          
          # 创建release
          RELEASE_RESPONSE=$(curl -s -X POST \
            -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            -H "Accept: application/vnd.github.v3+json" \
            "https://api.github.com/repos/${{ github.repository }}/releases" \
            -d "{
              \"tag_name\": \"${{ steps.get_release.outputs.tag_name }}\",
              \"name\": \"${{ steps.get_release.outputs.release_name }}\",
              \"body\": $(echo "$RELEASE_BODY" | jq -R -s .),
              \"draft\": false,
              \"prerelease\": false
            }")
          
          # 检查创建是否成功
          RELEASE_ID=$(echo "$RELEASE_RESPONSE" | jq -r '.id')
          if [ "$RELEASE_ID" = "null" ] || [ -z "$RELEASE_ID" ]; then
            echo "❌ 创建发布失败"
            echo "$RELEASE_RESPONSE" | jq .
            exit 1
          fi
          
          echo "✅ 发布创建成功，ID: $RELEASE_ID"
          echo "release_id=$RELEASE_ID" >> $GITHUB_OUTPUT
          
          # 获取发布信息（包含assets和源代码链接）
          RELEASE_INFO=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            -H "Accept: application/vnd.github.v3+json" \
            "https://api.github.com/repos/vernesong/OpenClash/releases/tags/${{ steps.get_release.outputs.tag_name }}")
          
          # 获取编译产物assets
          ASSETS=$(echo "$RELEASE_INFO" | jq -r '.assets[] | "\(.name)|\(.browser_download_url)"')
          
          # 获取源代码链接
          ZIPBALL_URL=$(echo "$RELEASE_INFO" | jq -r '.zipball_url')
          TARBALL_URL=$(echo "$RELEASE_INFO" | jq -r '.tarball_url')
          TAG_NAME="${{ steps.get_release.outputs.tag_name }}"
          
          # 创建临时目录
          mkdir -p /tmp/openclash_assets
          cd /tmp/openclash_assets
          
          # 下载编译产物
          if [ -n "$ASSETS" ] && [ "$ASSETS" != "null" ]; then
            ASSET_COUNT=$(echo "$ASSETS" | wc -l)
            echo "📦 找到 $ASSET_COUNT 个编译产物"
            
            echo "$ASSETS" | while IFS='|' read -r asset_name download_url; do
              echo "⬇️  下载编译产物: $asset_name"
              wget -q "$download_url" -O "$asset_name" &
            done
          else
            echo "⚠️  未找到编译产物"
          fi
          
          # 下载源代码文件
          echo "📄 下载源代码文件..."
          if [ -n "$ZIPBALL_URL" ] && [ "$ZIPBALL_URL" != "null" ]; then
            echo "⬇️  下载源代码 (zip): Source code.zip"
            wget -q "$ZIPBALL_URL" -O "Source code.zip" &
          fi
          
          if [ -n "$TARBALL_URL" ] && [ "$TARBALL_URL" != "null" ]; then
            echo "⬇️  下载源代码 (tar.gz): Source code.tar.gz"
            wget -q "$TARBALL_URL" -O "Source code.tar.gz" &
          fi
          
          # 等待所有下载完成
          wait
          
          # 统计下载的文件
          TOTAL_FILES=$(ls -1 | wc -l)
          echo "📁 总共下载了 $TOTAL_FILES 个文件"
          
          # 上传所有文件到新发布
          UPLOAD_SUCCESS=0
          UPLOAD_FAILED=0
          
          for file in *; do
            if [ -f "$file" ]; then
              echo "⬆️  上传: $file"
              
              # URL编码文件名，处理空格和特殊字符
              ENCODED_NAME=$(echo "$file" | sed 's/ /%20/g' | sed 's/\+/%2B/g')
              
              # 尝试上传文件，最多重试3次
              RETRY_COUNT=0
              UPLOAD_RESULT=1
              
              while [ $RETRY_COUNT -lt 3 ] && [ $UPLOAD_RESULT -ne 0 ]; do
                if [ $RETRY_COUNT -gt 0 ]; then
                  echo "🔄 重试上传 ($((RETRY_COUNT + 1))/3): $file"
                  sleep 2
                fi
                
                UPLOAD_RESPONSE=$(curl -s -w "%{http_code}" -X POST \
                  -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
                  -H "Content-Type: application/octet-stream" \
                  --data-binary @"$file" \
                  "https://uploads.github.com/repos/${{ github.repository }}/releases/$RELEASE_ID/assets?name=$ENCODED_NAME")
                
                HTTP_CODE="${UPLOAD_RESPONSE: -3}"
                UPLOAD_RESULT=$?
                
                if [ "$HTTP_CODE" = "201" ] && [ $UPLOAD_RESULT -eq 0 ]; then
                  echo "✅ $file 上传成功 (HTTP: $HTTP_CODE)"
                  UPLOAD_SUCCESS=$((UPLOAD_SUCCESS + 1))
                  break
                else
                  echo "⚠️  上传失败 (HTTP: $HTTP_CODE, Exit: $UPLOAD_RESULT)"
                  RETRY_COUNT=$((RETRY_COUNT + 1))
                fi
              done
              
              if [ $UPLOAD_RESULT -ne 0 ] || [ "$HTTP_CODE" != "201" ]; then
                echo "❌ $file 上传最终失败"
                UPLOAD_FAILED=$((UPLOAD_FAILED + 1))
              fi
            fi
          done
          
          echo "📊 上传统计: 成功 $UPLOAD_SUCCESS 个，失败 $UPLOAD_FAILED 个"
          
          if [ $UPLOAD_FAILED -gt 0 ]; then
            echo "⚠️  部分文件上传失败，但发布已创建"
            exit 0  # 不中断工作流，允许继续执行
          fi
          
          # 清理临时文件
          cd /
          rm -rf /tmp/openclash_assets
          
          echo "🎉 发布创建完成！"
          
      - name: Skip if release exists
        if: steps.check_release.outputs.exists == 'true' && steps.check_release.outputs.force_update == 'false'
        run: |
          echo "⏭️  跳过发布创建 - 版本 ${{ steps.get_release.outputs.tag_name }} 已存在"
          
      - name: Summary
        run: |
          echo "📊 === 执行摘要 ==="
          echo "🏷️  版本标签: ${{ steps.get_release.outputs.tag_name }}"
          echo "📅 发布时间: ${{ steps.get_release.outputs.published_at }}"
          echo "📁 原始资源文件: ${{ steps.get_release.outputs.assets_count }} 个编译产物 + 2 个源代码文件"
          
          if [ "${{ steps.check_release.outputs.exists }}" = "true" ] && [ "${{ steps.check_release.outputs.force_update }}" = "false" ]; then
            echo "ℹ️  状态: 发布已存在，未进行更新"
            echo "💡 提示: 如需强制更新，请在手动触发时启用 force_update 选项"
          elif [ "${{ steps.check_release.outputs.force_update }}" = "true" ]; then
            echo "🔄 状态: 强制更新完成 - 已同步所有文件（编译产物 + 源代码）"
            echo "🔗 查看发布: https://github.com/${{ github.repository }}/releases/tag/${{ steps.get_release.outputs.tag_name }}"
          else
            echo "🆕 状态: 新发布创建完成 - 已同步所有文件（编译产物 + 源代码）"
            echo "🔗 查看发布: https://github.com/${{ github.repository }}/releases/tag/${{ steps.get_release.outputs.tag_name }}"
          fi
          
          echo "📦 原始发布: https://github.com/vernesong/OpenClash/releases/tag/${{ steps.get_release.outputs.tag_name }}"
          echo "📋 同步内容:"
          echo "  ✅ 编译产物 (.apk, .ipk 文件)"
          echo "  ✅ 源代码文件 (zip, tar.gz)"
          echo "  📊 总计: 4 个文件完整同步"

